        스프링 부트란?

스프링 MVC를 사용하기 위해서는 필요한 프레임워크들과 라이브러리를 정확히 설정해야 하고, 기본적인 처리를 구축하기 위해
MVC의 각 코드를 작성해야 한다. 즉, 실질적인 프로그래밍에 앞서 복잡한 작업이 필요하다.
그래서 좀 더 효율적으로 최소한의 작업으로 스프링 MVC를 사용하기 위해 탄생한 것이 스프링 부트이다.

    어노테이션을 이용한 개발

스프링 부트는 최소한의 작업으로 개발할 수 있게 설계되었다고 해서 스프링 MVC와 다른 새로운 프레임워크가 아니다.
스프링 부트는 스프링 프레임워크에 포함된 프레임워크들을 통합해서 개발하기 쉬운 앱 애플리케이션 환경을 정비하는 것이다.
기존의 수많은 XML 설정 파일을 이용하지 않고, 어노테이션을 사용하는 방식으로 바뀌었다.
또한 비슷한 코드를 반복 작성하는 경우를 코드를 작성하지 않고 처리를 구현하는 방식으로 변경되었다.
실제로 데이터베이스 관련 처리는 클래스만 정의하면(메소드 정의 없이) 구현이 가능하다.
결국 스프링 부트는 스프링 MVC를 좀 더 편하게 사용하도록 만들어주는 도구이다.

        스프링 부트 애플리케이션

스프링 부트를 이용하는 애플리케이션은 그루비와 자바로 나누어 생각할 수 있다.

    그루비를 이용한 애플리케이션

스프링 부트는 그루비를 지원하며 자바 가상 머신상에서 동작하는 스크립트 언어인 그루비는 자바 문법을 기반으로 하여
상당히 단순화된 사양을 가지고 있다. 자바 프로그래머라면 별다른 학습 없이 사용가능하다.
그루비를 이용하면 매우 쉽게 웹 애플리케이션을 구축할 수 있다. 매우 쉬우며 텍스트 파일 하나만 작성하면 프로젝트 작성이
필요가 없다.
그루비로 개발하는 웹 애플리케이션은 본격적으로 개발에 앞서 프로토타입 등을 빠르게 개발해야 하는 경우에 도움이 된다.
단시간에 애플리케이션의 틀을 만들어서 보여주고 그것을 바탕으로 본격적인 개발에 들어가는 것이다.

    자바를 이용한 애플리케이션

스프링 부트의 일반적인 애플리케이션의 형태이다. 메이븐(또는 그레이들)이라는 빌드 툴을 사용하는 프로젝트로 생성되며
자바를 사용해 코딩한다. 이 애플리케이션은 메이븐 등의 빌드 툴 명령어를 사용해 실행할 수 있다.

        그루비 애플리케이션과 자바 애플리케이션

그루비를 사용하는 애플리케이션과 자바를 사용하는 것은 각각 장단점이 있다.
따라서 이 책에서는 사용하기 쉬운 그루비로 학습 후 자바로 학습한다.

그루비는 자바로 개발하는 스프링 부트 앱의 기본 부분을 간단하게 만들 수 있다. 이것이 그루비 앱의 이점이다.
간이 버전이지만 기본 부분은 자바와 같다. 이를 통해 자바로 본격적인 개발에 앞서 기본적인 개발 방식을 이해할 수 있다.
컨트롤러와 리퀘스트 매킹, 템플릿을 이용한 표시 등의 기본 개념은 그루비 앱과 자바 앱이 동일하다.
그루비는 가볍게 사용할 수 있으므로 원하는 것을 쉽게 스크립트 언어로 작성해서 기본적인 동작이나 사용법 등을 익힐 수 있다.

        스프링 부트 CLI 준비

간단한 그루비 앱을 만들어보기 위해서는 스프링 부트 CLI 소프트웨어를 설치하자.
스프링 부트 CLI zip 파일을 다운로드하여 압축 후 적당한 위치에 배치한다.

    환경 변수 path에 추가

시스템 변수에 Path에 해당 스프링 부트 CLI 내의 bin 폴더 경로를 추가한다.

        그루비 스크립트 작성하기

실제로 간이 스프링 부트 애플리케이션을 만들어보자. 간단한 메모장에 다음 스크립트를 입력하자.

    App.groovy

작성한 후 app.groovy 라는 이름으로 그루비 확장자를 가진 파일을 만들어 본다.

        app.groovy 실행하기

코드 내용은 뒤에서 설명 하고, 스크립트를 실행해보자. 명령 프롬프트 툴이나 터미널로 app.groovy가 위치하는 곳으로 이동한
후, 다음과 같이 파일을 실행한다.


    spring run app.groovy


이후 http://localhost:8080/ 에 접속해보자.

        그루비의 클래스 정의에 대해

이 스크립트는 그루비로 작성돼 있다.
그루비는 자바와 마찬가지로 '클래스' 를 정의해서 프로그래밍한다. 정의 방법이 자바와 약간 다르다.


    class 클래스명 {
        def 메소드명 (인수) {
            ... 처리 ...
        }
    }


클래스 정의는 자바와 같지만 메소드 정의는 def를 붙인다. 사실 그루비도 자바와 마찬가지로 반환값이나 키워드 등을 붙여
메소드를 정의할 수 있지만 이것들을 생략하고 def만 붙여서 정의할 수 있다. 이런 효율성 때문에 그루비에선 def 방식이
일반적이다.
앞의 코드 App 클래스 안에 home 메소드를 정의하고 있다. 그루비에도 상속 기능이 있지만 여기선 전혀 사용하고 있지 않다.
하지만 웹 애플리케이션 처럼 동작하는 이유는 어노테이션에 있다.

    @RequestMapping 어노테이션(REST 컨트롤러)

어노테이션은 자바에서도 사용되며 그루비의 어노테이션도 기본적으로 자바와 같이 클래스, 메소드, 필드 등에 부여할 수 있다.
클래스 정의 전에 @RestConroller 라는 어노에티션을 설정하고 있다. 이것은 해당 클래스가 REST 클래스라는 것을 의미한다.
REST란 REpresentational State Transfer의 약자로 분산 시스템을 위한 아키텍쳐다.
쉽게 말해 '외부로부터 접속해서 필요한 정보를 추출하기 위한 시스템' 을 만들 때 사용되는 것이다.
특정 서버에 접속해서 필요한 정보를 텍스트나 XML 등의 형태로 반환하는 시스템을 생각하면 된다.
이 @RestConroller 라는 어노테이션을 부여하므로 이 클래스는 REST 어노테이션의 '컨트롤러' 로 동작하게 된다.
컨트롤러라는 것은 MVC 아키텍쳐의 'Controller' 를 의미한다.
MVC 아키텍쳐에 대해선 뒤에서 다시 설명하지만 '컨트롤러는 애플리케이션 전체의 처리를 컨트롤하기 위한 것' 이라고
이해하면 된다. 즉, 애플리케이션에 접속했을 때의 처리를 컨트롤러에 기술하면 애플리케이션처럼 동작하게 된다.

    @RequestMapping 어노테이션 (리퀘스트 매핑)

이 App 클래스에는 home 메소드 하나가 있고 이 메소드에 @RequestMapping 어노테이션이 붙어 있다.
이것은 리퀘스트 매핑이라 불리는 기능을 부여하는 아노테이션이다. 쉽게 설명하면 '이 주소에 접속하면 이 메소드를 실행해'
라는 것으로 주소와 실행할 처리(메소드)를 연결하는 역할을 한다.
여기선 @RequestMapping("/") 이라고 해서 인수로 "/"를 사용하고 있다. http://???/ 에 접속한 경우 특정 메소드가 실행하게
하는 것이다. 즉, @RequestMapping의 인수에 경로를 지정하므로 해당 경로에 접속하면 특정 메소드가 실행되게 하는 것이다.
이렇게 특정 메소드에 접속하면 호출되는 메소드를 리퀘스트 핸들러라고 한다. 기본적으로는 '@RequestMapping 어노테이션이
붙은 메소드는 리퀘스트 핸들러' 라고 생각하면 된다.

    home 메소드의 처리

home 메소드에선 단순히 'Hello!!' 라는 텍스트를 메소드가 호출된 곳으로 반환하는 것을 의미한다.
그루비에선 메소드 마지막에 기록한 값이 그대로 반환 된다.
리퀘스트 매핑으로 설정한 메소드에선 반환된 텍스트를 그대로 클라이언트(웹 브라우저 등)에 전송한다.
따라서 여기선 'Hello!!' 라는 텍스트가 브라우저에 표시되는 것이다.


    ┌   ─   ─   ─   ─   ┐
    │       서버        │←    ─   ─   ─
    │┌  ─   ─ │ ─   ─  ┐│
    ││┌ ─   ─ ↓ ─   ─ ┐││                   클라이언트
    │││     메소드    │││                  (웹 브라우저)
    │││     반환값 ─   ─   ─   반환값 ─→
    ││└ ─   ─   ─   ─ ┘││
    ││      컨트롤러   ││
    │└  ─   ─   ─   ─  ┘│
    └   ─   ─   ─   ─   ┘


        HTML 표시하기

간단한 텍스트를 표시해보았으니 이제 일반적인 HTML 표시를 구현해보자.


    App2.groovy